import { Tooltip } from '../../components/mdx'

export const metadata = {
  pinned: false,
  title: '호이스팅(hoisting)이란?',
  description: '호이스팅은 JavaScript에서 변수 선언과 함수 선언이 코드 실행 전에 메모리로 끌어올려지는 동작을 말해요.',
  publishDate: "2025-07-24T20:32:11Z",
  image: '',
  tags: [
    'Frontend', 'Javascript', 'Hoisting',
  ],
};

# 호이스팅(Hoisting)이란?
자바스크립트는 **인터프리터 언어**라서 코드를 위에서부터 한 줄씩 읽고 실행해요. 따라서, 실제 실행에 들어가기 전, <Tooltip word="인터프리팅" title="인터프리팅">**코드를 한 줄씩 읽고 즉시 실행하는 방식**을 말해요. 실행 전에 전체를 기계어로 변환하는 컴파일과 달리, **읽으면서 곧바로 동작**해요.</Tooltip> 준비 단계에서 엔진은 먼저 **변수/함수 선언을 메모리에 등록**해 둬요.
이 때문에 선언이 코드 위로 끌어올려진 것처럼 보이는 현상을 **호이스팅**이라고 불러요.

## 예시
```js example.js
console.log(a); // undefined
var a = 10;
```
위 예시에서 `var a`는 인터프리팅 과정 중 **선언만** 메모리에 먼저 등록되었고,
값 할당(`= 10`)은 원래 위치에서 실행되기 때문에 `undefined`가 출력돼요.

## 특징
1. **`var`**
  선언이 호이스팅됨 → `undefined` 초기화돼요.

2. **`let`, `const`**
  선언은 호이스팅되지만 <Tooltip word="Temporal Dead Zone(TDZ)" title="일시적 사각지대">`let`·`const` 변수는 호이스팅되어 스코프에 등록되지만, **실제 초기화 전에 접근하면 오류가 발생하는 구간**을 말해요.</Tooltip>에 머무르기 때문에 초기화 전 접근 시 `ReferenceError` 발생해요.

3. **함수 선언문**
  선언 전체가 호이스팅돼서 어디에서든 호출 가능해요.
```js example.js
sayHi(); // ✅ 정상 실행

function sayHi() {
  console.log("안녕!");
}
```

4. **함수 표현식**
  변수 호이스팅만 일어나고, 할당된 함수는 원래 위치에서 정의돼요.
```js example.js
sayHello(); // ❌ TypeError: sayHello is not a function

var sayHello = function() {
  console.log("안녕!");
};
```

# 참고
[Github, 호이스팅(Hoisting)](https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/javascript/hoisting.md)
[Blog, 함수 표현식 VS 함수 선언식](https://velog.io/@bisu8018/%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D-VS-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EC%8B%9D)